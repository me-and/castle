#!/usr/bin/env bash

set -euo pipefail

if (( $# == 0 )); then
	report=next
	filter=()
else
	report="$1"
	filter=("${@:2}")
fi

make_toil () {
	echo 'Rebuilding toil...' >&2
	~/.local/src/toil/install.sh
	echo 'Done' >&2
}

if toil_path="$(command -v toil)"; then
	if [[ ~/.local/src/toil/toil.c -nt "$toil_path"
		|| ~/.local/src/toil/install.sh -nt "$toil_path" ]]; then
			make_toil
	fi
else
	make_toil
fi

umask 0077

toil_pid=
sleep_pid=
bash_pid=

tmpdir="$(mktemp -dt "taskloop.$report.$$.XXXXX")"

cleanup () {
	rm -rf "$tmpdir"
	local -a kill=()
	[[ "$toil_pid" ]] && kill+=("$toil_pid")
	[[ "$sleep_pid" ]] && kill+=("$sleep_pid")
	[[ "$bash_pid" ]] && kill+=("$bash_pid")
	if (( "${#kill[*]}" > 0 )); then
		# kill is allowed to return non-zero because it's fairly likely
		# some commands will have exited already.
		kill "${kill[@]}" 2>/dev/null || :
		wait "${kill[@]}"
	fi
}
trap cleanup EXIT

task_config_file="$tmpdir"/config
task_filter_file="$tmpdir"/filter
bash_in_use_flag_file="$tmpdir"/doingthings
explicit_exit_flag_file="$tmpdir"/explicitexit
sigterm_set_flag_file="$tmpdir"/bash-sigterm-set

data_path="$(task _get rc.data.location)"
data_path="${data_path%/}"

if [[ -v TASKRC ]]; then
	config_path="$TASKRC"
elif [[ -r "$HOME"/.taskrc ]]; then
	config_path="$HOME"/.taskrc
elif [[ -v XDG_CONFIG_HOME && -r "$XDG_CONFIG_HOME"/task/taskrc ]]; then
	config_path="$XDG_CONFIG_HOME"/task/taskrc
elif [[ -r "$HOME"/.config/task/taskrc ]]; then
	config_path="$HOME"/.config/task/taskrc
else
	echo 'Could not find a taskrc file' >&2
	exit 66  # EX_NOINPUT
fi

immediate_update_files=("$task_config_file" "$task_filter_file" "$config_path")
delay_update_files=("$data_path"/{completed,pending}.data)

have_limit=
for f in "${filter[@]}"; do
	if [[ "$f" = limit:* ]]; then
		have_limit=Yes
	fi
done
if [[ -z "$have_limit" ]]; then
	filter+=(limit:page)
fi
printf '%s\n' "${filter[@]}" >"$task_filter_file"

printf '%s\n' \
	reserved.lines=0 \
	verbose=blank,header,footnote,label,affected,context \
	gc=0 \
	>"$task_config_file"

while :; do
	# If toil isn't already running, start it to monitor for changes to
	# files that should trigger the task list to be redrawn if they change.
	if [[ -z "$toil_pid" ]] || ! kill -0 "$toil_pid" 2>/dev/null; then
		# Technically a window condition here: if files are edited
		# between here and when toil finishes reading the state of the
		# files as it starts up, those changes won't trigger a refresh.
		toil "${immediate_update_files[@]}" \
			"${delay_update_files[@]}" &
		toil_pid="$!"
	fi

	# Kill any running timer and restart it, as we want to redraw the table
	# intermittently regardless of whether there were any detected changes
	# in order to update things like due date intervals.
	if [[ "$sleep_pid" ]]; then
		kill "$sleep_pid" 2>/dev/null || :
	fi
	sleep 15m &
	sleep_pid="$!"

	# Draw the task list.
	mapfile -t config <"$task_config_file"
	mapfile -t filter <"$task_filter_file"
	task "${config[@]/#/rc.}" "${filter[@]}" "$report"

	# Start an interactive Bash shell so the user can enter task commands.
	rm -f "$sigterm_set_flag_file"
	bash_in_use_flag_file="$bash_in_use_flag_file" \
		explicit_exit_flag_file="$explicit_exit_flag_file" \
		sigterm_set_flag_file="$sigterm_set_flag_file" \
		tmpdir="$tmpdir" \
		bash --rcfile ~/.local/lib/taskloop/tasklooprc -i </dev/stdin &
	bash_pid="$!"

	# Wait for one of the three background processes to exit.
	if wait -np waited_pid "$toil_pid" "$sleep_pid" "$bash_pid"; then
		# One of the processes returned success.
		case "$waited_pid" in
			"$toil_pid")
				# A file change was detected.
				toil_pid=
				;;
			"$sleep_pid")
				# The timeout for doing a refresh has expired.
				sleep_pid=
				;;
			"$bash_pid")
				# Bash has exited, either because the user
				# successfully ran a command, or because Bash
				# timed out.  Assume the former and loop unless
				# the exit flag file exists.
				if [[ -e "$explicit_exit_flag_file" ]]; then
					# User explicitly ran the "exit"
					# command.
					exit 0
				else
					bash_pid=
				fi
				;;
			*)
				printf '%s:%s unexpected PID %s\n' \
					"$0" "$LINENO" \
					"$waited_pid" \
					>&2
				exit 70  # EX_SOFTWARE
				;;
		esac
	else
		# Non-zero return code or unexpected signal, so exit with that
		# return code.
		exit "$?"
	fi

	if [[ "$bash_pid" ]] && kill -0 "$bash_pid" 2>/dev/null; then
		# The interactive bash session is still running, so we need to
		# terminate it if the user doesn't appear to be using it, or
		# wait for it to be done if the user is using it.
		if [[ ! -e "$bash_in_use_flag_file" ]]; then
			# User doesn't appear to be using Bash, so send it a
			# term signal if it's still running.
			while [[ ! -e "$sigterm_set_flag_file" ]] && kill -0 "$bash_pid" 2>/dev/null; do
				# Bash hasn't yet indicated it has set the trap
				# on sigterm, so if we try to terminate it now,
				# the signal will be ignored.  Wait for the
				# file to exist before sending the signal.
				sleep 1
			done
			kill "$bash_pid" 2>/dev/null || :
		fi

		# Wait for the Bash process to exit.
		wait "$bash_pid" || :
	fi

	# Wait for files that might get multiple updates in rapid succession to
	# be stable for a couple of seconds, to avoid rapid cycling.
	mtimewait 2 "${delay_update_files[@]}"
done

# vim: ft=bash noet ts=8
