# I want to do Taskwarrior garbage collection daily, including on systems that
# don't have systemd.  Check when that was last done, and if it wasn't today,
# do it now.
if command -v systemctl >/dev/null; then
	# Systemctl is present, so assume anything of this ilk will be handled
	# by systemd.
	:
else
	_TASK_GC_TIMESTAMP_FILE=~/.local/share/task/.gclastrun
	_record_taskwarrior_gc () {
		for arg; do
			if [[ "$arg" = rc.gc[:=]1 ]]; then
				touch "$_TASK_GC_TIMESTAMP_FILE"
				break
			fi
		done
	}
	bashwrap task '_record_taskwarrior_gc "$@"'

	_taskwarrior_gc () {
		task rc.gc=1 rc.detection=off rc.color=off rc.hooks=off rc.recurrence=off rc.verbose=nothing status:pending count >/dev/null
	}
	_maybe_do_taskwarrior_gc () {
		local cutoff_dt
		local -i data_age now_s cutoff_s last_gc_s
		data_age="$(file-age ~/.local/share/task/undo.data)"

		# Check if the data file has changed in the last 30 minutes.
		# If it has, assume the user's recently active and we don't
		# want to do garbage collection under their feet.
		if (( data_age < (60*30) )); then
			return
		fi

		# Always do garbage collection if the timestamp file doesn't
		# exist.
		if [[ ! -e "$_TASK_GC_TIMESTAMP_FILE" ]]; then
			_taskwarrior_gc
			return
		fi

		# Check when garbage collection was last run; if it hasn't been
		# run since 4am this morning, run it now.  This works by
		# comparing the timestamp now in seconds since epoch to the
		# timestamp of the most recent 4am.
		printf -v cutoff_dt '%(%F)TT04:00' -1
		printf -v now_s '%(%s)T' -1
		cutoff_s="$(date -d "$_cutoff_dt" '+%s')"
		if (( cutoff_s >= now_s )); then
			# It's between midnight and 4am, so check whether garbage
			# collection was last run before or after 4am _yesterday_.
			(( cutoff_s -= (60*60*24) ))
		fi

		last_gc_s="$(date -r "$_TASK_GC_TIMESTAMP_FILE" '+%s')"
		if (( cutoff_s >= last_gc_s )); then
			_taskwarrior_gc
		fi
	}

	_maybe_do_taskwarrior_gc

	unset -f _taskwarrior_gc _maybe_do_taskwarrior_gc
fi

# I want to be able to display output, *probably* from task, every time the
# Bash prompt loads.
_fmtwrap () {
	printf '%s' "$@" | fmt -uw"$((${COLUMNS:-79}>79?79:COLUMNS))"
}

prompt_display () {
	if [[ -v TPFILTER ]]; then
		if [[ "$TPFILTER" ]]; then
			task "${TPFILTER[@]}"
		fi
	else
		_fmtwrap 'Set $TPFILTER to provide task filter prompts.'
		_fmtwrap 'Set $TPFILTER to an empty string to suppress this '\
			'message.'
		_fmtwrap 'Redefine the prompt_display function to get '\
			'something completely different here.'
	fi
}

_prompt_display_call () {
	if [[ -z "$SILENCE_PROMPT_DISPLAY" ]]; then
		if declare -Fp prompt_display &>/dev/null; then
			prompt_display
		else
			_fmtwrap 'No `prompt_display` function defined.  '\
				'Either define that function or set '\
				'SILENCE_PROMPT_DISPLAY=YesPlease to suppress '\
				'this message.'
		fi
	fi
}

# This based on the code in bash-git-prompt.
if (( BASH_VERSINFO[0] > 5 || BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 1 )); then
	PROMPT_COMMAND+=(_prompt_display_call)
else
	PROMPT_COMMAND+=';_prompt_display_call'
fi

# vim: ft=bash noet ts=8
