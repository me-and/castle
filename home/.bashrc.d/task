_task_quick_quiet () {
	command task rc.color=0 rc.detection=0 rc.gc=0 rc.hooks=0 rc.recurrence=0 rc.verbose=0 "$@"
}

# I want to do Taskwarrior garbage collection daily, including on systems that
# don't have systemd.  Check when that was last done, and if it wasn't today,
# do it now.
if command -v systemctl >/dev/null; then
	# Systemctl is present, so assume anything of this ilk will be handled
	# by systemd.
	:
else
	_TASK_GC_TIMESTAMP_FILE=~/.local/share/task/.gclastrun
	_record_taskwarrior_gc () {
		for arg; do
			if [[ "$arg" = rc.gc[:=]1 ]]; then
				touch "$_TASK_GC_TIMESTAMP_FILE"
				break
			fi
		done
	}
	bashwrap task '_record_taskwarrior_gc "$@"'

	_taskwarrior_gc () {
		command task rc.gc=1 rc.color=0 rc.detection=0 rc.hooks=0 rc.recurrence=0 rc.verbose=0 status:pending count >/dev/null &&
		touch "$_TASK_GC_TIMESTAMP_FILE"
	}
	_maybe_do_taskwarrior_gc () {
		local cutoff_dt
		local -i data_age now_s cutoff_s last_gc_s
		data_age="$(file-age ~/.local/share/task/undo.data)"

		# Check if the data file has changed in the last 30 minutes.
		# If it has, assume the user's recently active and we don't
		# want to do garbage collection under their feet.
		if (( data_age < (60*30) )); then
			return
		fi

		# Always do garbage collection if the timestamp file doesn't
		# exist.
		if [[ ! -e "$_TASK_GC_TIMESTAMP_FILE" ]]; then
			_taskwarrior_gc
			return
		fi

		# Check when garbage collection was last run; if it hasn't been
		# run since 4am this morning, run it now.  This works by
		# comparing the timestamp now in seconds since epoch to the
		# timestamp of the most recent 4am.
		printf -v cutoff_dt '%(%F)TT04:00' -1
		printf -v now_s '%(%s)T' -1
		cutoff_s="$(date -d "$cutoff_dt" '+%s')"
		if (( cutoff_s >= now_s )); then
			# It's between midnight and 4am, so check whether garbage
			# collection was last run before or after 4am _yesterday_.
			(( cutoff_s -= (60*60*24) ))
		fi

		last_gc_s="$(date -r "$_TASK_GC_TIMESTAMP_FILE" '+%s')"
		if (( cutoff_s >= last_gc_s )); then
			_taskwarrior_gc
		fi
	}

	_maybe_do_taskwarrior_gc

	unset -f _taskwarrior_gc _maybe_do_taskwarrior_gc
fi

# Configure taskwarrior-tui as `tt`, as suggested by its own documentation.
# Still not sure I want to keep using this tool, but while I am regularly using
# it...
#
# I see strange behaviour with taskwarrior-tui's terminal handling, so the
# function wrapper makes sure to reset things to an appropriate state before
# and after calling.
tt () {
	clear || return "$?"
	taskwarrior-tui "$@"
	local rc="$?"
	reset || return "$?"
	return "$rc"
}

# Function to enable `task <filter> (done-replace|del-replace) <new-task>`,
# which marks one task as done or deleted and creates a new task that has the
# same properties (including both blocked and blocking tasks) as the previous
# one.
#
# I'd prefer this to be a script with a Taskwarrior alias pointing to it, but
# that approach doesn't allow using the normal Taskwarrior interface of having
# filter arguments before the command and command arguments after it.
_task_done_replace () {
	[[ -v inside_task_done_replace ]] && return 0
	local inside_task_done_replace=Yes
	local old_uuid blocks arg name
	local -a filter_args description_args params column_names
	local -i n

	for (( n=1; n<=$#; n++ )); do
		if [[ "${!n}" = done-replace || "${!n}" = del-replace ]]; then
			filter_args=("${@:1:n-1}")
			old_uuid="$(_task_quick_quiet "${filter_args[@]}" _unique uuid)" || return "$?"
			if [[ -z "$old_uuid" ]]; then
				wrap_message <<<"No task matching filter ${filter_args[*]@Q}" >&2
				return 1
			elif [[ "$old_uuid" != ????????-????-????-????-???????????? ]]; then
				wrap_message <<<"More than one task matching filter ${filter_args[*]@Q}" >&2
				return 1
			fi
			blocks="$(_task_quick_quiet depends.has:"$old_uuid" _unique uuid)" || return "$?" # Newline separated
			blocks="${blocks//$'\n'/,}"  # Now it's comma separated

			# Left to its own devices, Taskwarrior will treat
			# arguments that aren't setting parameters as being
			# annotation text, where I'd rather they be treated as
			# the task description, similar to `task add`.  Work
			# out which arguments are task parameters and which
			# aren't.
			column_names=($(_task_quick_quiet _columns)) || "$?"
			for arg in "${@:n+1}"; do
				for name in "${column_names[@]}"; do
					if [[ "$arg" = "$name":* || "$arg" = '-'* || "$arg" = '+'* ]]; then
						params+=("$arg")
						continue 2
					fi
				done
				description_args+=("$arg")
			done

			if (( "${#description_args[*]}" == 0 )); then
				# No new description, so just use the old one.
				task "$old_uuid" duplicate blocks:"$blocks" "${params[@]}" || return "$?"
			else
				task "$old_uuid" duplicate blocks:"$blocks" "${params[@]}" description:"${description_args[*]}" || return "$?"
			fi

			if [[ "${!n}" = done-replace ]]; then
				task "$old_uuid" done || return "$?"
			else
				task "$old_uuid" delete || return "$?"
			fi
			did_done_replace=Yes
			return 0
		fi
	done
}

bashwrap task '
	local did_done_replace
	_task_done_replace "$@" || return "$?"
	[[ "$did_done_replace" ]] && return 0
	'

# Wrapper to allow the filter "project.sub:x" to be converted to
# "( project.is:x or project:x. )", i.e. excluding tasks with a project like
# "xx" which a simple "project:x" would pick up, and a similar rule for
# "project.nsub:".
bashwrap task '
	local -a newargs
	local arg val
	for arg; do
		if [[ "$arg" = project.sub:* ]]; then
			val="${arg#project.sub:}"
			newargs+=(\( project.is:"$val" or project:"$val". \))
		elif [[ "$arg" = project.nsub:* ]]; then
			val="${arg#project.nsub:}"
			newargs+=(\( project.isnt:"$val" project.not:"$val". \))
		else
			newargs+=("$arg")
		fi
	done
	set -- "${newargs[@]}"
	'

fo () {
	local uuid
	local -a uuids
	uuids=($(_task_quick_quiet "$@" _unique uuid)) || return "$?"
	if (( ${#uuids[*]} == 0 )); then
		echo 'No matched tasks' >&2
		return 1
	fi
	for uuid in "${uuids[@]}"; do
		TPFILTER+=(uuid.not:"$uuid")
	done
}

declare TPREPORT
declare -a TPFILTER
prompt_display () {
	if [[ "$TPREPORT" ]]; then
		if (( "${#TPFILTER[*]}" > 0 )); then
			local msg
			printf -v msg '%q ' "${TPFILTER[@]}"
			msg="filter: ${msg% }"
			cut_message "$msg"
		fi
		task "${TPFILTER[@]}" "$TPREPORT"
	fi
}

pnl () {
	local limit="$1"
	[[ "$limit" ]] || limit=page
	shift
	TPREPORT=next
	TPFILTER=(limit:"$limit" "$@")
}

pwl () {
	local limit="$1"
	[[ "$limit" ]] || limit=page
	shift
	TPREPORT=waitingfor
	TPFILTER=(limit:"$limit" "$@")
}

_taskloop_any_newer () {
	local file
	local target="$1"
	shift
	for file; do
		if [[ "$file" -nt "$target" ]]; then
			return 0
		fi
	done
	return 1
}

taskloop () {
	local -a files=(~/.local/share/task/*.data ~/.config/task/taskrc)
	local flagfile
	flagfile="$(mktemp -t "taskloop.$*.$$.XXXXX")" || return "$?"
	while :; do
		touch "$flagfile" || return "$?"
		task rc.reserved.lines=0 rc.verbose=header,footnote,label,affected,context rc.gc=0 rc.recurrence=0 limit:page "$@" || return "$?"
		while _taskloop_any_newer "$flagfile" "${files[@]}"; do
			touch "$flagfile" || return "$?"
			echo Updating... || return "$?"
			task rc.reserved.lines=0 rc.verbose=header,footnote,label,affected,context rc.gc=0 rc.recurrence=0 limit:page "$@" || return "$?"
		done
		inotifywait -qq -e modify "${files[@]}" || return "$?"
		echo Updating... || return "$?"
		mtimewait 1 "${files[@]}" || return "$?"
	done
}

# This based on the code in bash-git-prompt.
if (( BASH_VERSINFO[0] > 5 || BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 1 )); then
	PROMPT_COMMAND+=(prompt_display)
else
	PROMPT_COMMAND+=';prompt_display'
fi

# vim: ft=bash noet ts=8
