if [[ ! -v SSH_AUTH_SOCK ]] && command -v systemctl &>/dev/null; then
    # This system is governed by systemctl, so we can hopefully use systemctl
    # units to set up the ssh-agent.
    ssh_auth_sock_systemctl_env="$(systemctl --user show-environment | grep '^SSH_AUTH_SOCK=')"
    if [[ "$ssh_auth_sock_systemctl_env" ]]; then
        eval export "$ssh_auth_sock_systemctl_env"
    elif [[ "$XDG_RUNTIME_DIR" ]] && systemctl --user --quiet is-active ssh-agent.service; then
        export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/openssh_agent"
    fi
    unset ssh_auth_sock_systemctl_env
fi

if [[ ! -v SSH_AUTH_SOCK ]]; then
    # Set up ssh-agent the old-fashioned way.  Based on
    # https://www.cygwin.com/ml/cygwin/2001-06/msg00537.html
    if command -v ssh-agent &>/dev/null; then
        if [[ "$HOSTTYPE" ]]; then
            ssh_agent_pid_file=~/.ssh/ssh-agent."$HOSTTYPE".pid
        else
            ssh_agent_pid_file=~/.ssh/ssh-agent.pid
        fi

        function start_ssh_agent {
            rm -f "$ssh_agent_pid_file" || return 1

            # Create the file with a umask to ensure only the current user can
            # read/write to it.  The ssh-agent call must be outside the umask as
            # otherwise (at least on CentOS) it won't work.
            ssh-agent | ( umask 0177 && sed 's/^echo/#echo/' >"$ssh_agent_pid_file" )

            . "$ssh_agent_pid_file"
        }

        function ensure_ssh_agent_running {
            if [[ -r "$ssh_agent_pid_file" ]]; then
                . "$ssh_agent_pid_file"
                ssh-add -L &>/dev/null || start_ssh_agent
            else
                start_ssh_agent
            fi
        }

        ensure_ssh_agent_running
    else
        echo 'ssh-agent unavailable' >&2
        (( rc |= 0x10 ))
    fi
fi
